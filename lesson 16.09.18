Подключение кнопки с подтягивающим резистором
Давайте теперь подключим кнопку к ардуино так, чтобы можно было считывать в скетче ее состояние. Для этого воспользуемся следующей схемой.
В скетче мы будем отслеживать факт нажатия и выводить сообщение в монитор порта. Более интересный пример и подробное объяснение самой схемы мы приведем чуть позже.
Следует обратить внимание на сопротивление 10 К, которое мы добавили в этой схеме. Более подробно о его предназначении мы поговорим позже, просто имейте в виду, что такой резистор необходим для правильной работы схемы.
Скетч для кнопки ардуино с подтягивающим резистором:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
/*
  Пример использования тактовой кнопки в ардуино.
  Кнопка подключена к пину 2.
*/
 
const int PIN_BUTTON = 2;
 
void setup() {
  Serial.begin(9600);
  pinMode(PIN_LED, OUTPUT);
}
 
void loop() {
  // Получаем состояние кнопки и выводим в мониторе порта
  int buttonState = digitalRead(PIN_BUTTON);
  Serial.println(buttonState);
  delay(50);
}
Подключение кнопки в режиме INPUT_PULLUP
В указанной выше схеме мы использовали резистор, называемый подтягивающим, для формирования определенного уровня сигнала на цифровом порту. Но есть другой способ подключить кнопку без резистора, используя внутренне сопротивление платы ардуино. В блоке setup мы должны всего лишь определить тип пина, к которому подключим кнопку, как INPUT_PULLUP.
1
pinMode(PIN_BUTTON, INPUT_PULLUP);
Альтернативным вариантом будет выбрать режим пина как OUTPUT и установить на данный порт высокий уровень сигнала. Встроенный подтягивающий резистор подключиться автоматически.
1
2
3
pinMode(PIN_BUTTON, INPUT_PULLUP);
 
digitalWrite(PIN_BUTTON, HIGH);
И все. Можно собрать вот такую сложную схему и работать с кнопкой в скетче.

Мигание светодиода после нажатия на кнопку
В предыдущем примере со светодиодами мы подключили кнопку к плате ардуино и поняли, как она работает. Светодиод включался и выключался, но делал это в совершенно пассивном режиме – сам контроллер здесь был абсолютно лишним, его можно было бы заменить батарейками. Поэтому давайте сделаем наш новый проект более «интеллектуальным»: при нажатии на кнопку заставим светодиод непрерывно мигать. Обычной схемой с лампочкой и выключателем этого уже не сделаешь — мы будем использовать мощь нашего микроконтроллера для решения этой пусть и простой, но не тривиальной задачи.
Полная схема проекта изображена на рисунке:

Фрагмент схемы со светодиодом уже хорошо нам знаком. Мы собрали обычный маячок со светодиодом и ограничительным резистором. А вот во второй части мы видим знакомую нам кнопку и еще один резистор. Пока не будем вдаваться в подробности, просто соберем схему и закачаем в ардуино простой скетч. Все элементы схемы  идут в самых простых стартовых наборах ардуино.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
/*
  Скетч для схемы с использованием тактовой кнопки и светодиода
  Светодиод мигает, пока нажата кнопка.
  Кнопка подтянута к земле, нажатию соответствует HIGH на входе
*/
 
const int PIN_BUTTON = 2;
const int PIN_LED = 13;
 
void setup() {
  Serial.begin(9600);
  pinMode(PIN_LED, OUTPUT);
}
 
void loop() {
  // Получаем состояние кнопки
  int buttonState = digitalRead(PIN_BUTTON);
  Serial.println(buttonState);
  // Если кнопка не нажата, то ничего не делаем
  if (!buttonState) {
    delay(50);
    return;
  }
 
  // Этот блок кода будет выполняться, если кнопка нажата
  // Мигаем светодиодом
  digitalWrite(PIN_LED, HIGH);
  delay(1000);
  digitalWrite(PIN_LED, LOW);
  delay(1000);
}
Нажимаем и держим – светодиод мигает. Отпускаем – он гаснет. Именно то , что хотели. Хлопаем от радости в ладоши и приступаем к анализу того, что сделали.
Давайте посмотрим на скетч. В нем мы видим довольно простую логику.
Определяем, нажата ли кнопка.
Если кнопка не нажата, то просто выходим из метода loop, ничего не включая и не меняя.
Если кнопка нажата, то выполняем мигание, используя фрагмент стандартного скетча: 
Включаем светодиод, подавая напряжение на нужный порт
Делаем нужную паузу при включенном светодиоде
Выключаем светодиод
Делаем нужную паузу при выключенном светодиоде
Логика поведения кнопки в скетче может зависеть от способа подключения с подтягивающим резистором. Об этом мы поговорим в следующей статье.
Дребезг кнопки ардуино
В процессе работы с кнопками мы можем столкнуться с очень неприятным явлением, называемым дребезгом кнопки. Как следует из самого названия, явление это обуславливается дребезгом контактов внутри кнопочного переключателя. Металлические пластины соприкасаются друг с другом не мгновенно (хоть и очень быстро для наших глаз), поэтому на короткое время в зоне контакта возникают скачки и провалы напряжения. Если мы не предусмотрим появление таких «мусорных» сигналов, то будем реагировать на них каждый раз и можем привести наш проект к хаусу.
Для устранения дребезга используют программные и аппаратные решения. В двух словах лишь упомянем основные методы подавления дребезга:
Добавляем в скетче паузу 10-50 миллисекунд между полкучением значений с пина ардуино.
Если мы используем прерывания, то программный метд использоваться не может и мы формируем аппаратную защиту. Простейшая из них  — RC фильтр с конденсатором и сопротивлением.
Для более точного подавления дребезга используется аппаратный фильтр с использованием триггера шмидта. Этот вариант позволит получить на входе в ардуино сигнал практически идеальной формы.
Более подробную информацию о способах борьбы с дребезгом вы можете найти в этой статье об устранении дребезга кнопок.
Переключение режимов с помощью кнопки
Для того, чтобы определить, была ли нажата кнопка, надо просто зафиксировать факт ее нажатия и сохранить признак в специальной переменной.
Факт нажатия мы определяем с помощью функции digitalRead(). В результате мы получим HIGH (1, TRUE) или LOW(0, FALSE), в зависимости от того, как подключили кнопку. Если мы подключаем кнопку с помощью внутреннего подтягивающего резистора, то нажатие кнопки приведет к появлению на входе уровня 0 (FALSE).
Для хранения информации о нажатии на кнопку можно использовать переменную типа boolean:
boolean keyPressed = digitalRead(PIN_BUTTON)==LOW;
Почему мы используем такую конструкцию, а не сделали так:
boolean keyPressed = digitalRead(PIN_BUTTON);
Все дело в том, что digitalRead() может вернуть HIGH, но оно не будет означать нажатие кнопки. В случае использования схемы с подтягивающим резистором HIGH будет означать, что кнопка, наоборот, не нажата. В первом варианте (digitalRead(PIN_BUTTON)==LOW ) мы сразу сравнили вход с нужным нам значением и определили, что кнопка нажата, хотя и на входе сейчас низкий уровень сигнала. И сохранили в переменную статус кнопки. Старайтесь явно указывать все выполняемые вами логические операции, чтобы делать свой код более прозрачным и избежать лишних глупых ошибок.
Как переключать режимы работы после нажатия кнопки?
Часто возникает ситуация, когда мы с помощью кнопок должны учитывать факт не только нажатия, но и отпускания кнопки. Например, нажав и отпустив кнопку, мы можем включить свет или переключить режим работы схемы.  Другими словами, нам нужно как-то зафиксировать в коде факт нажатия на кнопку и использовать информацию в дальнейшем, даже если кнопка уже не нажата.  Давайте посмотрим, как это можно сделать.
Логика работы программы очень проста:
Запоминаем факт нажатия в служебной переменной.
Ожидаем, пока не пройдут явления, связанные с дребезгом.
Ожидаем факта отпускания кнопки.
Запоминаем факт отпускания и устанавливаем в отдельной переменной признак того, что кнопка была полноценно нажата.
Очищаем служебную переменную.
